# Лабораторная 2 — HTTP поверх TCP

## Цель

Понять, как HTTP работает поверх TCP.

Реализовать минимальный HTTP-сервер, используя только модуль `net` в Node.js, без Express и без встроенного `http`-модуля.

Основная идея:

HTTP — это обычный текст, передаваемый по TCP-соединению.

---

## Архитектура

- TCP-сервер, созданный через `net.createServer`
- TCP-клиент, созданный через `net.createConnection`
- Данные передаются в виде строк
- Вся логика HTTP реализуется вручную:
  - парсинг запроса
  - формирование ответа
  - работа с границами сообщений

---

## Структура HTTP-запроса

HTTP-запрос состоит из четырёх логических частей:

```
HTTP request
├── request line
├── headers
├── empty line
└── body (опционально)
```

---

### Request line

Первая строка HTTP-запроса:

```
GET / HTTP/1.1
```

Она всегда содержит три элемента:

- метод (`GET`)
- путь (`/`)
- версию протокола (`HTTP/1.1`)

Request line не является заголовком. Это отдельная часть протокола.

---

### Headers

Заголовки имеют формат:

```
Header-Name: Header-Value
```

Пример:

```
Host: localhost
User-Agent: my-tcp-client/1.0
```

Особенности заголовков:

- порядок не имеет значения
- регистр имён не важен
- заголовков может быть много
- значения могут содержать символ `:`

---

### Пустая строка

Пустая строка отделяет заголовки от тела запроса.

Граница всегда обозначается последовательностью:

```
\r\n\r\n
```

---

### Body

Тело запроса является необязательным и обычно используется в POST или PUT запросах.

Пример:

```
{"name":"John"}
```

Размер тела определяется заголовком `Content-Length`.

---

## Парсинг HTTP-запроса

Базовый алгоритм парсинга:

1. Преобразовать входящий `Buffer` в строку
2. Найти разделитель `\r\n\r\n`
3. Разделить запрос на:
   - секцию заголовков
   - тело (на этом этапе не используется)

4. Разбить секцию заголовков по `\r\n`
5. Первая строка — request line
6. Остальные строки — заголовки

---

### Преобразование заголовков в объект

Для каждой строки заголовка:

- найти первый символ `:`
- левая часть — имя заголовка
- правая часть — значение
- обрезать пробелы
- привести имя заголовка к нижнему регистру

Пример результата:

```
{
  host: "localhost",
  "user-agent": "my-tcp-client/1.0"
}
```

---

## Структура HTTP-ответа

HTTP-ответ имеет следующую структуру:

```
HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Content-Length: 20
Connection: close

Hello from raw HTTP!
```

---

### Обязательные части ответа

1. Status line (`HTTP/1.1 200 OK`)
2. Заголовки:
   - Content-Type
   - Content-Length
   - Connection

3. Пустая строка
4. Тело ответа

---

## Content-Length

Заголовок `Content-Length` должен содержать количество байт, а не символов.

В Node.js длина тела вычисляется с помощью:

```
Buffer.byteLength(body, "utf8")
```

Без `Content-Length` клиент не понимает, где заканчивается тело ответа.

---

## Закрытие соединений

Для корректного закрытия соединения с клиентом после отправки ответа используется:

```
socket.end()
```

Это гарантирует отправку всех данных и корректное завершение TCP-соединения.

---

Для остановки сервера и освобождения порта используется:

```
server.close()
```

---

## Результат

- Клиент получает корректный HTTP-ответ
- Тело ответа принимается полностью
- Соединение закрывается корректно
- Сервер логирует разобранный запрос:
  - метод
  - путь
  - версию HTTP
  - заголовки

---

## Ограничения текущей реализации

Реализация является намеренно упрощённой:

- отсутствует буферизация TCP
- предполагается, что запрос приходит одним чанком
- отсутствует парсинг тела запроса
- не поддерживается несколько запросов в одном соединении

Эти ограничения ожидаемы на данном этапе.

---

## Основные выводы

- HTTP — текстовый протокол
- TCP работает как поток, а не как сообщения
- Границы сообщений определяются протоколом, а не TCP
- `Content-Length` критически важен для корректной работы
- Фреймворки вроде Express являются надстройками над этой логикой
  тот конспект отражает реальные шаги и выводы, сделанные в ходе лабораторной.
