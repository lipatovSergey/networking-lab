**_TCP (Transmission Control Protocol)_** — это протокол транспортного уровня, который создаёт надёжное соединение между двумя устройствами и гарантирует, что все данные будут доставлены **корректно, в правильном порядке и без потерь**.
Он делает это за счёт предварительного установления соединения, проверки получения каждого фрагмента данных и повторной отправки данных, если что-то потерялось.

**_IP_ (Internet Protocol Address)** — уникальный числовой идентификатор, назначаемый устройству в сети.
Пример: `195.34.32.116`

**_Port_** — идентификатор, который позволяет операционной системе направлять входящие сетевые данные в нужное приложение.

**_Socket_** — комбинация IP-адреса и номера порта, которая однозначно идентифицирует точку сетевого соединения.

---

## Заметки: TCP-сервер и клиент. Поток байтов и протокол поверх TCP

В этой лабораторной работе я реализовал **TCP-сервер** и **TCP-клиент**, используя встроенный модуль `net` в Node.js.

---

### 1. Что такое TCP на практике

TCP — это транспортный протокол, который **позволяет клиенту и серверу обмениваться данными**.
Перед отправкой любых данных TCP **устанавливает соединение**. На этом этапе обе стороны обмениваются специальными управляющими сообщениями (handshake).

TCP гарантирует, что:

- данные будут доставлены надёжно,
- порядок данных будет сохранён,
- потерянные данные будут отправлены повторно в случае ошибки.

---

### 2. Сервер и порт

Сервер **слушает определённый порт** (в нашем случае порт `4000`).
Мы задаём серверу инструкцию:

> «Если кто-то подключается к этому порту, считай его клиентом и реагируй на его действия следующим образом».

**К одному порту могут подключаться несколько клиентов одновременно.**

Каждое клиентское подключение — это отдельный **socket**, который однозначно определяется:

- IP-адресом клиента,
- номером порта клиента.

Таким образом, один серверный порт может обслуживать множество параллельных подключений.

---

### 3. Поток байтов и чанки

TCP **не передаёт сообщения**.
TCP передаёт **поток байтов**, который приложение получает в виде **чанков**.

Важно понимать:

- один `write` **не равен** одному `chunk`,
- один `chunk` может содержать данные из нескольких вызовов `write`,
- один `write` может прийти в виде нескольких `chunk`.

То, как данные группируются в чанки, зависит от:

- операционной системы,
- TCP-буферов,
- состояния сети,
- алгоритма Нэйгла.

Алгоритм Нэйгла старается **отправлять данные минимальным количеством чанков**:

> если данные можно отправить вместе, они, скорее всего, будут объединены.

---

### 4. Кодировка и UTF-8

TCP передаёт **байты**, а не текст.
В Node.js `chunk` — это объект типа `Buffer`.

Чтобы работать с текстом, мы:

- декодируем байты в строку с помощью UTF-8,
- используем `chunk.toString("utf8")`.

Это важно, потому что:

- UTF-8 — многобайтовая кодировка,
- один символ может занимать несколько байтов,
- байты одного символа могут быть разделены между разными чанками.

---

### 5. Протокол поверх TCP (line protocol)

Чтобы корректно восстанавливать сообщения из потока байтов, обе стороны должны **договориться о протоколе**.

В этой лабораторной работе использовался **строковый протокол**:

- каждое сообщение **должно заканчиваться символом `\n`**,
- и сервер, и клиент следуют этому правилу.

---

### 6. Буферизация и разбор сообщений

Как обрабатываются данные:

1. Создаётся строковая переменная `buffer`.

2. Для каждого входящего `chunk`:
   - он декодируется из UTF-8,
   - **добавляется в buffer**.

3. Пока `buffer` содержит `\n`:
   - берётся подстрока от начала до `\n` — это **одно полное сообщение**,
   - оставшиеся данные сохраняются обратно в `buffer`, чтобы **избежать потери данных**,
   - сообщение обрабатывается.

Буферизация **обязательна**, иначе части данных или символов могут быть потеряны.

---

### 7. Итог

- TCP — это **поток байтов**, а не протокол сообщений.
- TCP **не определяет границы сообщений**.
- Поверх TCP **всегда требуется протокол**.
- Самый простой протокол — использование разделителя, например `\n`.
- Буферизация и разбор по разделителю — базовый паттерн для текстовых протоколов.
- HTTP, Redis, SMTP и многие другие протоколы работают по тому же принципу.

---

### 8. Надёжность, ACK и закрытие соединения (FIN)

TCP гарантирует надёжную доставку **на уровне байтов**, а не сообщений.

Для этого TCP внутренне использует:

- **порядковые номера байтов** — каждый байт в потоке имеет позицию,
- **ACK (acknowledgment)** — подтверждение полученных байтов,
- **повторную передачу** — потерянные байты автоматически отправляются заново.

Как работает ACK на концептуальном уровне:

- получатель подтверждает **все байты до определённого номера**,
- ACK вида `ACK = 5002` означает:

  > «Я получил все байты до 5001 и жду байт 5002».

Важные моменты про ACK:

- ACK **не отправляется после каждого байта**,
- один ACK обычно подтверждает **сразу диапазон байтов**,
- если ACK долго не продвигается, отправитель считает данные потерянными и переотправляет их.

---

#### Обработка потерь данных

Если часть байтов теряется во время передачи:

- получатель продолжает подтверждать **последний непрерывно полученный байт**,
- отправитель замечает отсутствие прогресса,
- отправитель **переотправляет недостающие байты**.

Этот процесс **полностью скрыт от кода приложения**.
С точки зрения Node.js:

- либо данные приходят корректно,
- либо соединение закрывается с ошибкой.

---

#### Завершение соединения (FIN)

TCP не угадывает, когда данные закончились.
Конец потока байтов всегда **явно сигнализируется**.

Чтобы завершить отправку данных, сторона отправляет флаг **FIN**, который означает:

> «Я больше не буду отправлять байты».

Важные детали:

- FIN — это **не байт данных**, а управляющий сигнал,
- FIN **не означает**, что другая сторона уже получила все данные,
- FIN означает только, что **эта сторона закончила отправку**.

TCP-соединение закрывается **в обе стороны**:

1. одна сторона отправляет `FIN`,
2. другая сторона подтверждает его (`ACK`),
3. другая сторона отправляет свой `FIN`,
4. первая сторона подтверждает его (`ACK`).

Только после этого TCP-соединение считается полностью закрытым.

---

#### Ключевой вывод о надёжности

- TCP гарантирует **упорядоченную и надёжную доставку байтов**,
- TCP **не знает** о сообщениях, запросах или ответах,
- TCP **не знает**, сколько байтов «должно» быть отправлено,
- границы сообщений и длина данных должны определяться протоколом **выше TCP** (например, HTTP).

---
